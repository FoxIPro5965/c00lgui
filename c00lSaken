local repo="https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/"
local Library=loadstring(game:HttpGet(repo.."Library.lua"))()
local ThemeManager=loadstring(game:HttpGet(repo.."addons/ThemeManager.lua"))()
local SaveManager=loadstring(game:HttpGet(repo.."addons/SaveManager.lua"))()

local Window = Library:CreateWindow({
    Title = "c00lSaken",
    Footer = "by FoxOfficial",
    Center = true,
    AutoShow = true,
    ToggleKeybind = Enum.KeyCode.RightControl
})

local RoleTab = Window:AddTab({ Name = "Role", Icon = "user" })
local AutoBlockTab = Window:AddTab({ Name = "Autoblock", Icon = "shield" })
local BackstabTab = Window:AddTab({ Name = "AutoBackstab", Icon = "swords" })
local VisualTab = Window:AddTab({ Name = "Visuals", Icon = "eye" })
local AntiTab = Window:AddTab({ Name = "Anti", Icon = "ban" })
local OtherTab = Window:AddTab({ Name = "Other", Icon = "settings" })
local ConfigTab = Window:AddTab({ Name = "Config", Icon = "folder" })

ThemeManager:SetLibrary(Library)
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:ApplyToTab(ConfigTab)
SaveManager:BuildConfigSection(ConfigTab)
Library.ForceCheckbox=true

local Players=game:GetService("Players")
local ReplicatedStorage=game:GetService("ReplicatedStorage")
local RunService=game:GetService("RunService")
local Lighting=game:GetService("Lighting")
local lp=Players.LocalPlayer
local PlayerGui=lp:WaitForChild("PlayerGui")

do
    local voidrushcontrol = false

    local function setupCharacter(character)
        if not character then return end
        local Humanoid = character:FindFirstChild("Humanoid")
        local HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if Humanoid and HumanoidRootPart then
            _G.Humanoid = Humanoid
            _G.HumanoidRootPart = HumanoidRootPart
        end
    end

    if lp.Character then setupCharacter(lp.Character) end
    lp.CharacterAdded:Connect(setupCharacter)

    local ORIGINAL_DASH_SPEED = 55
    local isOverrideActive = false
    local connection

    local function startOverride()
        if isOverrideActive then return end
        isOverrideActive = true
        connection = RunService.RenderStepped:Connect(function()
            local humanoid = _G.Humanoid
            local rootPart = _G.HumanoidRootPart
            if not humanoid or not rootPart then return end
            humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
            humanoid.AutoRotate = false
            local direction = rootPart.CFrame.LookVector
            local horizontal = Vector3.new(direction.X, 0, direction.Z)
            if horizontal.Magnitude > 0 then
                humanoid:Move(horizontal.Unit)
            end
        end)
    end

    local function stopOverride()
        if not isOverrideActive then return end
        isOverrideActive = false
        local humanoid = _G.Humanoid
        if humanoid then
            humanoid.WalkSpeed = 18
            humanoid.AutoRotate = true
            humanoid:Move(Vector3.new(0, 0, 0))
        end
        if connection then connection:Disconnect() connection = nil end
    end

    RunService.RenderStepped:Connect(function()
        if not voidrushcontrol then return end
        local char = _G.Humanoid and _G.Humanoid.Parent
        local voidRushState = char and char:GetAttribute("VoidRushState")
        if voidRushState == "Dashing" then
            startOverride()
        else
            stopOverride()
        end
    end)
    local NoliGroup = RoleTab:AddLeftGroupbox("Noli")
    NoliGroup:AddToggle("VoidrushControl", {
        Text = "Voidrush Controllable",
        Default = false,
        Callback = function(v)
            voidrushcontrol = v
        end
    })
end

do
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer
    local device = "Mobile"

    local function getBehaviorFolder()
        return ReplicatedStorage:WaitForChild("Assets")
            :WaitForChild("Survivors")
            :WaitForChild("Veeronica")
            :WaitForChild("Behavior")
    end

    local function getSprintingButton()
        return player.PlayerGui:WaitForChild("MainUI"):WaitForChild("SprintingButton")
    end

    local behaviorFolder = getBehaviorFolder()

    local function safeConnectPropertyChanged(instance, prop, fn)
        local ok, signal = pcall(function() return instance:GetPropertyChangedSignal(prop) end)
        if ok and signal then return signal:Connect(fn) end
        return nil
    end

    local enabled = false
    local activeMonitors = {}
    local descendantAddedConn = nil

    local function monitorHighlight(h)
        if not h or activeMonitors[h] then return end

        local connections = {}
        local prevState = false

        local function cleanup()
            for _, conn in ipairs(connections) do
                if conn and conn.Connected then conn:Disconnect() end
            end
            activeMonitors[h] = nil
        end

        local function adorneeIsPlayerCharacter()
            local adornee = h.Adornee
            local char = player.Character
            if not adornee or not char then return false end
            return adornee == char or adornee:IsDescendantOf(char)
        end

        local function onChanged()
            if not enabled then return end
            if not h or not h.Parent then cleanup() return end

            local currState = adorneeIsPlayerCharacter()
            if prevState ~= currState and currState then
                if device == "Mobile" then
                    local ok, btn = pcall(getSprintingButton)
                    if ok and btn then
                        for _, v in pairs(getconnections(btn.MouseButton1Down)) do
                            pcall(v.Fire, v)
                        end
                    end
                end
            end
            prevState = currState
        end

        local c = safeConnectPropertyChanged(h, "Adornee", onChanged)
        if c then table.insert(connections, c) end

        table.insert(connections, h.AncestryChanged:Connect(function(_, parent)
            if not parent then cleanup() else onChanged() end
        end))

        table.insert(connections, player.CharacterAdded:Connect(onChanged))
        table.insert(connections, player.CharacterRemoving:Connect(onChanged))

        activeMonitors[h] = cleanup
        task.spawn(onChanged)
    end

    local function startManager()
        if descendantAddedConn then return end
        for _, desc in ipairs(behaviorFolder:GetDescendants()) do
            if desc:IsA("Highlight") then monitorHighlight(desc) end
        end
        descendantAddedConn = behaviorFolder.DescendantAdded:Connect(function(child)
            if child:IsA("Highlight") then monitorHighlight(child) end
        end)
    end

    local function stopManager()
        if descendantAddedConn and descendantAddedConn.Connected then
            descendantAddedConn:Disconnect()
        end
        descendantAddedConn = nil
        for _, cleanup in pairs(activeMonitors) do pcall(cleanup) end
        activeMonitors = {}
    end

    local function setEnabled(v)
        if enabled == v then return end
        enabled = v
        if enabled then startManager() else stopManager() end
    end
    local VerronicaGroup = RoleTab:AddRightGroupbox("Verronica")
    VerronicaGroup:AddToggle("AutoTrick", {
        Text = "Auto Trick",
        Default = false,
        Callback = function(v)
            setEnabled(v)
        end
    })
end

local autoBlockTriggerSounds = {
["102228729296384"]=true,["140242176732868"]=true,["112809109188560"]=true,["136323728355613"]=true,
["115026634746636"]=true,["84116622032112"]=true,["108907358619313"]=true,["127793641088496"]=true,
["86174610237192"]=true,["95079963655241"]=true,["101199185291628"]=true,["119942598489800"]=true,
["84307400688050"]=true,["113037804008732"]=true,["105200830849301"]=true,["75330693422988"]=true,
["82221759983649"]=true,["81702359653578"]=true,["108610718831698"]=true,["112395455254818"]=true,
["109431876587852"]=true,["109348678063422"]=true,["85853080745515"]=true,["12222216"]=true,
["105840448036441"]=true,["114742322778642"]=true,["119583605486352"]=true,["79980897195554"]=true,
["71805956520207"]=true,["79391273191671"]=true,["89004992452376"]=true,["101553872555606"]=true,
["101698569375359"]=true,["106300477136129"]=true,["116581754553533"]=true,["117231507259853"]=true,
["119089145505438"]=true,["121954639447247"]=true,["125213046326879"]=true,["131406927389838"]=true
}
local autoBlockTriggerAnims = {
    "rbxassetid://126830014841198","rbxassetid://126355327951215","rbxassetid://121086746534252",
    "rbxassetid://18885909645","rbxassetid://98456918873918","rbxassetid://105458270463374",
    "rbxassetid://83829782357897","rbxassetid://125403313786645","rbxassetid://118298475669935",
    "rbxassetid://82113744478546","rbxassetid://70371667919898","rbxassetid://99135633258223",
    "rbxassetid://97167027849946","rbxassetid://109230267448394","rbxassetid://139835501033932",
    "rbxassetid://126896426760253","rbxassetid://109667959938617","rbxassetid://126681776859538",
    "rbxassetid://129976080405072","rbxassetid://121293883585738","rbxassetid://81639435858902",
    "rbxassetid://137314737492715","rbxassetid://92173139187970","rbxassetid://122709416391",
    "rbxassetid://879895330952",

    "rbxassetid://131430497821198","rbxassetid://127172483138092","rbxassetid://18885919947",
    "rbxassetid://87259391926321","rbxassetid://106014898528300","rbxassetid://86545133269813",
    "rbxassetid://89448354637442","rbxassetid://90499469533503","rbxassetid://116618003477002",
    "rbxassetid://106086955212611","rbxassetid://107640065977686","rbxassetid://77124578197357",
    "rbxassetid://101771617803133","rbxassetid://134958187822107","rbxassetid://111313169447787",
    "rbxassetid://71685573690338","rbxassetid://129843313690921","rbxassetid://97623143664485",
    "rbxassetid://136007065400978","rbxassetid://86096387000557","rbxassetid://108807732150251",
    "rbxassetid://138040001965654","rbxassetid://73502073176819","rbxassetid://86709774283672",
    "rbxassetid://140703210927645","rbxassetid://96173857867228","rbxassetid://121255898612475",
    "rbxassetid://98031287364865","rbxassetid://119462383658044","rbxassetid://77448521277146",
    "rbxassetid://103741352379819","rbxassetid://131696603025265","rbxassetid://122503338277352",
    "rbxassetid://97648548303678","rbxassetid://94162446513587","rbxassetid://84426150435898",
    "rbxassetid://93069721274110","rbxassetid://114620047310688","rbxassetid://97433060861952",
    "rbxassetid://82183356141401","rbxassetid://100592913030351","rbxassetid://70447634862911",
    "rbxassetid://106847695270773","rbxassetid://120112897026015","rbxassetid://74707328554358",
    "rbxassetid://133336594357903","rbxassetid://86204001129974","rbxassetid://124243639579224",
    "rbxassetid://131543461321709","rbxassetid://136323728355613"
}

local autoBlockOn = false
local autoBlockAudioOn = false
local detectionRange = 12
local facingCheckEnabled = true
local customFacingDot = -0.3
local blockdelay = 0
local autoPunch = false
local aimPunch = false
local aimPrediction = 4
local backstab = false
local backstabRange = 8
local backstabMode = "Around"
local visualEnabled = false
local showKiller = false
local showSurvivor = false
local showItems = false
local showGen = false
local infStamina = true
local jumpEnabled = false
local hitbox = false
local HitboxModule
local autoGen = true
local autoGenSpeed = 0.1
local undetectedMode = false

local LeftAB = AutoBlockTab:AddLeftGroupbox("Auto Block")
local RightAB = AutoBlockTab:AddRightGroupbox("Autopunch")

LeftAB:AddToggle("AutoBlockAnim", {Text = "Auto Block (Animation)", Default = false, Callback = function(v) autoBlockOn = v end})
LeftAB:AddToggle("AutoBlockAudio", {Text = "Auto Block (Audio)", Default = false, Callback = function(v) autoBlockAudioOn = v end})
LeftAB:AddInput("DetectionRange", {Text = "Detection Range", Default = "12", Numeric = true, Callback = function(t) detectionRange = tonumber(t) or detectionRange end})
LeftAB:AddToggle("FacingCheck", {Text = "Enable Facing Check", Default = true, Callback = function(v) facingCheckEnabled = v end})
LeftAB:AddInput("FacingDot", {Text = "Facing Check DOT", Default = "-0.3", Numeric = true, Callback = function(t) customFacingDot = tonumber(t) or customFacingDot end})
LeftAB:AddInput("BlockDelay", {Text = "Block Delay (seconds)", Default = "0", Numeric = true, Callback = function(t) blockdelay = tonumber(t) or blockdelay end})

RightAB:AddToggle("Autopunch", {Text = "Autopunch", Default = false, Callback = function(v) autoPunch = v end})
RightAB:AddToggle("Aimpunch", {Text = "Aimpunch", Default = false, Callback = function(v) aimPunch = v end})
RightAB:AddSlider("Prediction", {Text = "Prediction", Min = 0, Max = 10, Default = 4, Increment = 0.1, Suffix = " studs", Callback = function(v) aimPrediction = v end})

local LeftBS = BackstabTab:AddLeftGroupbox("Auto Backstab")
LeftBS:AddToggle("AutoBackstab", {Text = "AutoBackstab", Default = false, Callback = function(v) backstab = v end})
LeftBS:AddInput("BackstabRange", {Text = "Range", Default = "8", Numeric = true, Callback = function(t) backstabRange = tonumber(t) or backstabRange end})
LeftBS:AddDropdown("BackstabMode", {Text = "Mode", Default = "Around", Values = {"Behind", "Around"}, Callback = function(v) backstabMode = v end})

local LeftVis = VisualTab:AddLeftGroupbox("ESP Settings")
LeftVis:AddToggle("Highlight", {Text = "Highlight", Default = false, Callback = function(v) visualEnabled = v end})
LeftVis:AddToggle("Killer", {Text = "Killer", Default = false, Callback = function(v) showKiller = v end})
LeftVis:AddToggle("Survivor", {Text = "Survivor", Default = false, Callback = function(v) showSurvivor = v end})
LeftVis:AddToggle("Generator", {Text = "Generator", Default = false, Callback = function(v) showGen = v end})
LeftVis:AddToggle("Items", {Text = "Medkit & BloxyCola", Default = false, Callback = function(v) showItems = v end})

local LeftOther = OtherTab:AddLeftGroupbox("Misc")
LeftOther:AddToggle("InfStamina", {Text = "INF STAMINA", Default = true, Callback = function(v) infStamina = v end})
LeftOther:AddToggle("Jump", {Text = "Jump", Default = false, Callback = function(v) jumpEnabled = v end})
LeftOther:AddToggle("Hitbox", {Text = "Hitbox", Default = false, Callback = function(v)
    hitbox = v
    if v then
        HitboxModule = HitboxModule or loadstring(game:HttpGet("https://raw.githubusercontent.com/FoxIPro5965/c00lgui/main/Hitbox.lua"))()
        HitboxModule:ExtendHitbox(1.25, 585)
    elseif HitboxModule then
        HitboxModule:StopExtendingHitbox()
    end
end})
LeftOther:AddToggle("AutoGen", {Text = "Auto gen", Default = true, Callback = function(v) autoGen = v end})
LeftOther:AddSlider("GenSpeed", {Text = "Gen Speed", Min = 0.05, Max = 0.5, Default = 0.1, Increment = 0.005, Callback = function(v) autoGenSpeed = v end})
LeftOther:AddToggle("Undetected", {Text = "Undetected Mode", Default = false, Callback = function(v) undetectedMode = v end})
LeftOther:AddToggle("HakariDance", {
    Text = "Hakari Dance",
    Default = false,
    Callback = function(state)
        local char = lp.Character or lp.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")

        if state then
            Library:Notify("Hakari Dance activated!", 5)
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0

            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart

            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://138019937280193"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()

            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://87166578676888"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = true
            sound:Play()

            local effect = ReplicatedStorage.Assets.Emotes.HakariDance.HakariBeamEffect:Clone()
            effect.Name = "PlayerEmoteVFX"
            effect.CFrame = char.PrimaryPart.CFrame * CFrame.new(0, -1, -0.3)
            effect.WeldConstraint.Part0 = char.PrimaryPart
            effect.WeldConstraint.Part1 = effect
            effect.Parent = char
            effect.CanCollide = false

            local args = {"PlayEmote", "Animations", "HakariDance"}
            ReplicatedStorage.Modules.Network.RemoteEvent:FireServer(unpack(args))

            animationTrack.Stopped:Connect(function()
                if not LeftOther.Options.HakariDance.Value then
                    humanoid.PlatformStand = false
                    if bodyVelocity and bodyVelocity.Parent then bodyVelocity:Destroy() end
                end
            end)
        else
            humanoid.PlatformStand = false
            humanoid.JumpPower = 50

            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end

            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound and sound.SoundId:find("87166578676888") then
                sound:Stop()
                sound:Destroy()
            end

            local effect = char:FindFirstChild("PlayerEmoteVFX")
            if effect then effect:Destroy() end

            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://138019937280193" then
                    track:Stop()
                end
            end
        end
    end
})

local antiStun=false
local antiSlow=false
local antiBlindness=false
local antiSubspace=false
local antiHiddenStats=false
local toggleState=false
local originalValues={}

local AntiGroup=AntiTab:AddLeftGroupbox("Anti")
local anti1xConn

AntiGroup:AddToggle("Anti1x", {
    Text = "Anti 1x1x1x1 popups",
    Default = false,
    Callback = function(state)
        _G.no1x = state

        if anti1xConn then
            anti1xConn:Disconnect()
            anti1xConn = nil
        end

        if not state then return end

        local function handlePopup(popup)
            task.wait(0.5) 
            if firesignal and popup and popup:IsA("ImageButton") then
                pcall(function()
                    firesignal(popup.MouseButton1Click)
                end)
            end
        end

        local function scan(gui)
            if gui.Name ~= "TemporaryUI" then return end
            local popup = gui:FindFirstChild("1x1x1x1Popup")
            if popup then
                handlePopup(popup)
            end
            gui.ChildAdded:Connect(function(c)
                if c.Name == "1x1x1x1Popup" then
                    handlePopup(c)
                end
            end)
        end

        for _,ui in ipairs(lp.PlayerGui:GetChildren()) do
            scan(ui)
        end

        anti1xConn = lp.PlayerGui.ChildAdded:Connect(scan)
    end
})

AntiGroup:AddToggle("AntiStun",{
Text="Anti Stun",
Default=false,
Callback=function(v)
antiStun=v
task.spawn(function()
while antiStun and task.wait() do
local char=lp.Character
if char and char:FindFirstChild("SpeedMultipliers") then
local s=char.SpeedMultipliers:FindFirstChild("Stunned")
if s then s.Value=2 end
end
end
end)
end})

AntiGroup:AddToggle("AntiSlow",{
Text="Anti Slow",
Default=false,
Callback=function(v)
antiSlow=v
task.spawn(function()
while antiSlow and task.wait() do
local char=lp.Character
if char and char:FindFirstChild("SpeedMultipliers") then
for _,m in ipairs(char.SpeedMultipliers:GetChildren()) do
if m.Value<1 then m.Value=1 end
end
end
end
end)
end})

AntiGroup:AddToggle("AntiBlind",{
Text="Anti Blindness",
Default=false,
Callback=function(v)
antiBlindness=v
task.spawn(function()
while antiBlindness and task.wait() do
local b=Lighting:FindFirstChild("BlindnessBlur")
if b then b:Destroy() end
end
end)
end})

AntiGroup:AddToggle("AntiSubspace",{
Text="Anti Subspace",
Default=false,
Callback=function(v)
antiSubspace=v
task.spawn(function()
while antiSubspace and task.wait() do
local a=Lighting:FindFirstChild("SubspaceVFXBlur")
local b=Lighting:FindFirstChild("SubspaceVFXColorCorrection")
if a then a:Destroy() end
if b then b:Destroy() end
end
end)
end})

local paths={"HideKillerWins","HidePlaytime","HideSurvivorWins"}

local function saveOriginals(p)
originalValues[p.UserId]=originalValues[p.UserId] or {}
for _,k in ipairs(paths) do
local v=p.PlayerData.Settings.Privacy:FindFirstChild(k)
if v then originalValues[p.UserId][k]=v.Value end
end
end

local function reveal(p)
for _,k in ipairs(paths) do
local v=p.PlayerData.Settings.Privacy:FindFirstChild(k)
if v then v.Value=false end
end
end

local function restore(p)
if not originalValues[p.UserId] then return end
for k,val in pairs(originalValues[p.UserId]) do
local v=p.PlayerData.Settings.Privacy:FindFirstChild(k)
if v then v.Value=val end
end
end

local function hiddenStatsFunc(on)
for _,p in ipairs(Players:GetPlayers()) do
if on then
saveOriginals(p)
reveal(p)
else
restore(p)
end
end
end

Players.PlayerAdded:Connect(function(p)
if toggleState then
saveOriginals(p)
reveal(p)
end
end)

AntiGroup:AddToggle("AntiHiddenStats",{
Text="Anti Hidden Stats",
Default=false,
Callback=function(v)
toggleState=v
antiHiddenStats=v
hiddenStatsFunc(v)
end})

local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

local cachedBlockBtn, cachedCooldown
local function refreshUIRefs()
    local main = PlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedBlockBtn = ability and ability:FindFirstChild("Block")
        cachedCooldown = cachedBlockBtn and cachedBlockBtn:FindFirstChild("CooldownTime")
    end
end
refreshUIRefs()
PlayerGui.ChildAdded:Connect(function(child)
    if child.Name == "MainUI" then task.delay(0.02, refreshUIRefs) end
end)
lp.CharacterAdded:Connect(function() task.delay(0.5, refreshUIRefs) end)

local function click(btnName)
    local ui = PlayerGui:FindFirstChild("MainUI")
    local btn = ui and ui:FindFirstChild("AbilityContainer") and ui.AbilityContainer:FindFirstChild(btnName)
    if not btn then return end
    for _, c in ipairs(getconnections(btn.MouseButton1Click)) do pcall(function() c:Fire() end) end
    pcall(function() btn:Activate() end)
end

local function isFacing(myRoot, targetRoot)
    if not facingCheckEnabled then return true end
    local dir = (myRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return dot > customFacingDot
end

local soundHooks = {}
local soundBlockedUntil = {}
local lastLocalBlockTime = 0
local AUDIO_LOCAL_COOLDOWN = 0.35

local function extractNumericSoundId(sound)
    local sid = sound.SoundId
    if type(sid) ~= "string" then sid = tostring(sid) end
    return sid:match("rbxassetid://(%d+)") or sid:match("://(%d+)") or sid:match("^(%d+)$")
end

local function hookSound(sound)
    if not sound:IsA("Sound") or soundHooks[sound] then return end
    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end
    soundHooks[sound] = true
    local function tryBlock()
        if not autoBlockAudioOn then return end
        if tick() - lastLocalBlockTime < AUDIO_LOCAL_COOLDOWN then return end
        if soundBlockedUntil[sound] and tick() < soundBlockedUntil[sound] then return end
        local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        local parent = sound.Parent
        while parent and not parent:FindFirstChild("HumanoidRootPart") do parent = parent.Parent end
        local hrp = parent and parent:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if (hrp.Position - myRoot.Position).Magnitude > detectionRange then return end
        if facingCheckEnabled and not isFacing(myRoot, hrp) then return end
        refreshUIRefs()
        if cachedCooldown and cachedCooldown.Text ~= "" then return end
        task.wait(blockdelay)
        click("Block")
        lastLocalBlockTime = tick()
        soundBlockedUntil[sound] = tick() + 1
    end
    sound.Played:Connect(tryBlock)
    sound:GetPropertyChangedSignal("IsPlaying"):Connect(function() if sound.IsPlaying then tryBlock() end end)
    if sound.IsPlaying then tryBlock() end
end

for _, desc in ipairs(KillersFolder:GetDescendants()) do if desc:IsA("Sound") then hookSound(desc) end end
KillersFolder.DescendantAdded:Connect(function(desc) if desc:IsA("Sound") then hookSound(desc) end end)

RunService.RenderStepped:Connect(function()
    if not autoBlockOn then return end
    local myChar = lp.Character
    if not myChar then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    refreshUIRefs()
    if cachedCooldown and cachedCooldown.Text ~= "" then return end
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        local hrp = killer:FindFirstChild("HumanoidRootPart")
        if hrp and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
            local hum = killer:FindFirstChildOfClass("Humanoid")
            local animator = hum and hum:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    local animId = tostring(track.Animation.AnimationId):match("%d+")
                    if animId and table.find(autoBlockTriggerAnims, animId) then
                        if not facingCheckEnabled or isFacing(myRoot, hrp) then
                            task.wait(blockdelay)
                            click("Block")
                            return
                        end
                    end
                end
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if not autoPunch then return end
    local myChar = lp.Character
    if not myChar then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local gui = PlayerGui:FindFirstChild("MainUI")
    local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
    local charges = punchBtn and punchBtn:FindFirstChild("Charges")
    if not charges or charges.Text ~= "1" then return end
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local root = killer:FindFirstChild("HumanoidRootPart")
        if root and (root.Position - myRoot.Position).Magnitude <= 10 then
            if aimPunch then
                local humanoid = myChar:FindFirstChildOfClass("Humanoid")
                if humanoid then humanoid.AutoRotate = false end
                task.spawn(function()
                    local startTime = tick()
                    while tick() - startTime < 1 do
                        if myRoot and root and root.Parent then
                            local predictedPos = root.Position + (root.CFrame.LookVector * aimPrediction)
                            myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                        end
                        task.wait()
                    end
                    if humanoid then humanoid.AutoRotate = true end
                end)
            end
            click("Punch")
            break
        end
    end
end)

local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
local lastBackstab = 0
local COOLDOWN = 10
local HOLD = 0.29
local DIST = 2

local function isBehind(hrp, khrp)
    if (hrp.Position - khrp.Position).Magnitude > backstabRange then return false end
    if backstabMode == "Around" then return true end
    return (hrp.Position - khrp.Position):Dot(-khrp.CFrame.LookVector) > 0.5
end

RunService.Heartbeat:Connect(function()
    if not backstab or tick() - lastBackstab < COOLDOWN then return end
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    for _, k in ipairs(killersFolder:GetChildren()) do
        local khrp = k:FindFirstChild("HumanoidRootPart")
        if khrp and isBehind(hrp, khrp) then
            lastBackstab = tick()
            click("Dagger")
            local s = tick()
            local c
            c = RunService.Heartbeat:Connect(function()
                if tick() - s > HOLD then c:Disconnect() return end
                hrp.CFrame = CFrame.new(khrp.Position - khrp.CFrame.LookVector * DIST, khrp.Position)
            end)
            break
        end
    end
end)

local oldA, oldO, oldB, oldF = Lighting.Ambient, Lighting.OutdoorAmbient, Lighting.Brightness, Lighting.FogEnd
local function bright(on)
    if on then
        Lighting.Ambient = Color3.new(1,1,1)
        Lighting.OutdoorAmbient = Color3.new(1,1,1)
        Lighting.Brightness = 6
        Lighting.FogEnd = 0
    else
        Lighting.Ambient = oldA
        Lighting.OutdoorAmbient = oldO
        Lighting.Brightness = oldB
        Lighting.FogEnd = oldF
    end
end

local function addHL(obj, color)
    if obj:FindFirstChild("VisualHL") then return end
    local h = Instance.new("Highlight")
    h.Name = "VisualHL"
    h.FillTransparency = 1
    h.OutlineTransparency = 0
    h.OutlineColor = color
    h.Parent = obj
    h.Adornee = obj
end

local function clearVisual()
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("Highlight") and v.Name == "VisualHL" then v:Destroy() end
    end
end

task.spawn(function()
    while task.wait(0.5) do
        if not visualEnabled then clearVisual() bright(false) continue end
        bright(true)
        clearVisual()
        local pf = workspace:FindFirstChild("Players")
        if pf then
            if showKiller and pf:FindFirstChild("Killers") then
                for _, k in ipairs(pf.Killers:GetChildren()) do
                    if k:FindFirstChild("Humanoid") then addHL(k, Color3.fromRGB(255,70,70)) end
                end
            end
            if showSurvivor and pf:FindFirstChild("Survivors") then
                for _, s in ipairs(pf.Survivors:GetChildren()) do
                    if s:FindFirstChild("Humanoid") then addHL(s, Color3.fromRGB(70,255,70)) end
                end
            end
        end
        if showItems then
            for _, i in ipairs(workspace:GetDescendants()) do
                if i.Name == "Medkit" or i.Name == "BloxyCola" then addHL(i, Color3.fromRGB(180,0,255)) end
            end
        end
        if showGen then
            for _, g in ipairs(workspace:GetDescendants()) do
                if g.Name:lower():find("generator") then addHL(g, Color3.fromRGB(255,255,0)) end
            end
        end
    end
end)

local flipHeight = 8
local flipDistance = 8

LeftOther:AddToggle("FrontFlip", { 
    Text = "Front Flip",
    Tooltip = "funny flip",
    Default = true,
    Callback = function(v)
        getgenv().FlipUI.Enabled = v
    end
}):AddKeyPicker("FlipKeybind", {
    Default = "F",
    Text = "Flip keybind",
    NoUI = false,
    Callback = function()
        if not LeftOther.Options.FrontFlip.Value then return end
        FortniteFlips()
    end,
})

LeftOther:AddSlider("FlipHeight", {
    Text = "Flip Height",
    Min = 5,
    Max = 35,
    Default = 8,
    Rounding = 1,
    Callback = function(v)
        flipHeight = v
    end
})

LeftOther:AddSlider("FlipDistance", {
    Text = "Flip Distance",
    Min = 5,
    Max = 35,
    Default = 8,
    Rounding = 1,
    Callback = function(v)
        flipDistance = v
    end
})

local FlipCooldown = false

function FortniteFlips()
    if FlipCooldown then
        return
    end

    FlipCooldown = true
    local character = lp.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
    if not hrp or not humanoid then
        FlipCooldown = false
        return
    end

    local savedTracks = {}

    if animator then
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            savedTracks[#savedTracks + 1] = { track = track, time = track.TimePosition }
            track:Stop(0)
        end
    end

    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)

    local duration = 0.45
    local steps = 120
    local startCFrame = hrp.CFrame
    local forwardVector = startCFrame.LookVector
    local upVector = Vector3.new(0, 1, 0)
    task.spawn(function()
        local startTime = tick()
        for i = 1, steps do
            local t = i / steps
            local height = 4 * (t - t ^ 2) * flipHeight
            local nextPos = startCFrame.Position + forwardVector * (flipDistance * t) + upVector * height
            local rotation = startCFrame.Rotation * CFrame.Angles(-math.rad(i * (360 / steps)), 0, 0)

            hrp.CFrame = CFrame.new(nextPos) * rotation
            local elapsedTime = tick() - startTime
            local expectedTime = (duration / steps) * i
            local waitTime = expectedTime - elapsedTime
            if waitTime > 0 then
                task.wait(waitTime)
            end
        end

        hrp.CFrame = CFrame.new(startCFrame.Position + forwardVector * flipDistance) * startCFrame.Rotation
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Running)

        if animator then
            for _, data in ipairs(savedTracks) do
                local track = data.track
                track:Play()
                track.TimePosition = data.time
            end
        end
        task.wait(0.25)
        FlipCooldown = false
    end)
end

local Flip = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local button = Instance.new("ImageButton")
local UICorner = Instance.new("UICorner")
local move = Instance.new("ImageLabel")

Flip.Name = "Flip"
Flip.Parent = gethui()
Flip.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Flip.DisplayOrder = 999999
Flip.OnTopOfCoreBlur = true

Frame.Parent = Flip
Frame.AnchorPoint = Vector2.new(1, 1)
Frame.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(1, -30, 1, -30)
Frame.Size = UDim2.new(0, 98, 0, 44)

button.Name = "button"
button.Parent = Frame
button.AnchorPoint = Vector2.new(0, 0.5)
button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundTransparency = 1.000
button.BorderColor3 = Color3.fromRGB(0, 0, 0)
button.BorderSizePixel = 0
button.Position = UDim2.new(0, 5, 0.5, 0)
button.Size = UDim2.new(0, 36, 0, 36)
button.Image = "rbxassetid://114905930912702"
Instance.new("UICorner", button).CornerRadius = UDim.new(0, 8)

UICorner.CornerRadius = UDim.new(0, 13)
UICorner.Parent = Frame

move.Name = "move"
move.Parent = Frame
move.AnchorPoint = Vector2.new(1, 0.5)
move.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
move.BackgroundTransparency = 1.000
move.BorderColor3 = Color3.fromRGB(0, 0, 0)
move.BorderSizePixel = 0
move.Position = UDim2.new(1, -5, 0.5, 0)
move.Size = UDim2.new(0, 36, 0, 36)
move.Image = "rbxassetid://107178621515925"

local UIS = game:GetService("UserInputService")
local function dragify(Frame, DragInp)
	local dragToggle = nil
	local dragInput = nil
	local dragStart = nil
	local Delta
	local Position
	local startPos
	local function updateInput(input)
		Delta = input.Position - dragStart
		Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
		Frame.Position = Position
	end
	DragInp.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
			dragToggle = true
			dragStart = input.Position
			startPos = Frame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)
	DragInp.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragToggle then
			updateInput(input)
		end
	end)
end
dragify(Frame, move)
getgenv().FlipUI = Flip
button.MouseButton1Click:Connect(FortniteFlips)

task.spawn(function()
    local Undetectable = require(ReplicatedStorage.Modules.StatusEffects.Undetectable)
    local animationId = "rbxassetid://75804462760596"
    local loadedAnim = nil
    local function play(char)
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then
            local anim = Instance.new("Animation")
            anim.AnimationId = animationId
            loadedAnim = hum:LoadAnimation(anim)
            loadedAnim:Play()
            loadedAnim:AdjustSpeed(0)
        end
    end
    local function stop()
        if loadedAnim then loadedAnim:Stop() loadedAnim = nil end
    end
    local oA = Undetectable.Applied
    local oR = Undetectable.Removed
    Undetectable.Applied = function(d)
        if undetectedMode and d.Player == lp then play(d.Character or d.Player.Character) end
        return oA(d)
    end
    Undetectable.Removed = function(d)
        if undetectedMode and d.Player == lp then stop() end
        return oR(d)
    end
end)

local FlowGameModule
local oldNew
local hookedGen = false

local function isNeighbour(r1, c1, r2, c2)
    return (r2 == r1-1 and c2 == c1) or (r2 == r1+1 and c2 == c1) or (r2 == r1 and c2 == c1-1) or (r2 == r1 and c2 == c1+1)
end

local function key(n) return n.row .. "-" .. n.col end

local function orderPath(path, endpoints)
    if not path or #path == 0 then return path end
    local start = endpoints and endpoints[1] or path[1]
    local pool = {}
    for _, n in ipairs(path) do pool[key(n)] = {row = n.row, col = n.col} end
    local ordered = {}
    local cur = {row = start.row, col = start.col}
    table.insert(ordered, cur)
    pool[key(cur)] = nil
    while next(pool) do
        local found = false
        for k, n in pairs(pool) do
            if isNeighbour(cur.row, cur.col, n.row, n.col) then
                table.insert(ordered, n)
                pool[k] = nil
                cur = n
                found = true
                break
            end
        end
        if not found then break end
    end
    return ordered
end

local HintSystem = {}
function HintSystem:Draw(puzzle)
    if not puzzle or not puzzle.Solution then return end
    for i = 1, #puzzle.Solution do
        local path = puzzle.Solution[i]
        local ends = puzzle.targetPairs[i]
        local ordered = orderPath(path, ends)
        puzzle.paths[i] = {}
        for _, node in ipairs(ordered) do
            if not autoGen then return end
            table.insert(puzzle.paths[i], {row = node.row, col = node.col})
            puzzle:updateGui()
            task.wait(autoGenSpeed)
        end
        puzzle:checkForWin()
    end
end

local function hookAutoGen()
    if hookedGen then return end
    local mod = ReplicatedStorage.Modules.Misc.FlowGameManager.FlowGame
    FlowGameModule = require(mod)
    oldNew = oldNew or FlowGameModule.new
    FlowGameModule.new = function(...)
        local puzzle = oldNew(...)
        task.spawn(function()
            if autoGen then HintSystem:Draw(puzzle) end
        end)
        return puzzle
    end
    hookedGen = true
end

hookAutoGen()

task.spawn(function()
    local sprint = require(ReplicatedStorage.Systems.Character.Game.Sprinting)
    while task.wait(3) do
        if infStamina then sprint.Stamina = sprint.MaxStamina or 100 end
    end
end)

task.spawn(function()
    while task.wait(0.2) do
        local hum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum.JumpPower = jumpEnabled and 60 or 0 end
    end
end)
do
    local JasonEnabled = false
    local OriginalParts = {}

    local Jason = game:GetService("ReplicatedStorage").Assets.Killers.Jason
    local Slasher = game:GetService("ReplicatedStorage").Assets.Killers.Slasher

    local function ApplyJason()
        require(Slasher.Behavior).Abilities.Slash.Icon = require(Jason.Behavior).Abilities.Slash.Icon
        require(Slasher.Behavior).Abilities.Behead.Icon = require(Jason.Behavior).Abilities.Behead.Icon
        require(Slasher.Behavior).Abilities.GashingWound.Icon = require(Jason.Behavior).Abilities.GashingWound.Icon
        require(Slasher.Behavior).Abilities.RagingPace.Icon = require(Jason.Behavior).Abilities.RagingPace.Icon

        local SoundsSlasher = require(Slasher.Config).Sounds
        SoundsSlasher["TerrorRadiusThemes"] = require(Jason.Config).Sounds.TerrorRadiusThemes
        require(Slasher.Config).DisplayName = "Jason"
        require(Slasher.Config).RenderImage = require(Jason.Config).RenderImage
    end

    local function AddJasonMask(char)
        local head = char:FindFirstChild("Head")
        if not head then return end

        local mask = Instance.new("Accessory")
        mask.Name = "JasonMask"

        local handle = Instance.new("Part")
        handle.Name = "Handle"
        handle.Size = Vector3.new(1,1,1)
        handle.Transparency = 1
        handle.CanCollide = false
        handle.Massless = true
        handle.Parent = mask

        local mesh = Instance.new("SpecialMesh")
        mesh.MeshId = "rbxassetid://17176629012"
        mesh.TextureId = "rbxassetid://17176629042"
        mesh.Parent = handle

        local weld = Instance.new("WeldConstraint")
        weld.Part0 = head
        weld.Part1 = handle
        weld.Parent = handle

        handle.CFrame = head.CFrame * CFrame.new(0, -0.1, 0.6)

        mask.Parent = char
        return mask
    end

    local function OnCharacter(char)
        if char.Name ~= "Slasher" or char.Parent ~= workspace.Players.Killers or char:GetAttribute("SkinName") ~= "" then return end

        OriginalParts[char] = {
            Shirt = char:FindFirstChildOfClass("Shirt"),
            Pants = char:FindFirstChildOfClass("Pants"),
            OldMask = char:FindFirstChild("Mask"),
            ChainsawNote = char:FindFirstChild("Chainsaw") and char.Chainsaw:FindFirstChild("Note"),
            SlasherExport = char:FindFirstChild("Slasher Export"),
            LimbsTransparency = {}
        }
        local orig = OriginalParts[char]
        for _, limb in pairs({"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
            local part = char:FindFirstChild(limb)
            if part then orig.LimbsTransparency[limb] = part.Transparency end
        end

        if JasonEnabled then
            if orig.SlasherExport then orig.SlasherExport:Destroy() end
            if orig.ChainsawNote then orig.ChainsawNote:Destroy() end
            if orig.OldMask then orig.OldMask:Destroy() end

            for _, limb in pairs({"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
                local part = char:FindFirstChild(limb)
                if part then part.Transparency = 0 end
            end

            local shirt = Instance.new("Shirt", char)
            shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=1502643168"
            local pants = Instance.new("Pants", char)
            pants.PantsTemplate = "http://www.roblox.com/asset/?id=1502651303"

            AddJasonMask(char)
        end
    end

    local function RevertJason(char)
        local orig = OriginalParts[char]
        if not orig then return end

        if char:FindFirstChildOfClass("Shirt") and char:FindFirstChildOfClass("Shirt") ~= orig.Shirt then
            char:FindFirstChildOfClass("Shirt"):Destroy()
        end
        if char:FindFirstChildOfClass("Pants") and char:FindFirstChildOfClass("Pants") ~= orig.Pants then
            char:FindFirstChildOfClass("Pants"):Destroy()
        end
        local jasonMask = char:FindFirstChild("JasonMask")
        if jasonMask then jasonMask:Destroy() end

        for limb, trans in pairs(orig.LimbsTransparency) do
            local part = char:FindFirstChild(limb)
            if part then part.Transparency = trans end
        end

        OriginalParts[char] = nil
    end

    lp.CharacterAdded:Connect(function(char)
        if JasonEnabled then ApplyJason() end
        task.wait(1)
        OnCharacter(char)
    end)

    if lp.Character then
        task.wait(1)
        OnCharacter(lp.Character)
    end

    local SkinGroup = RoleTab:AddLeftGroupbox("Skin")

    SkinGroup:AddToggle("JasonSkin", {
        Text = "Jason",
        Default = false,
        Callback = function(v)
            JasonEnabled = v

            if v then
                ApplyJason()
                Library:Notify("Jason skin enabled!", 4)
                if lp.Character then OnCharacter(lp.Character) end
            else
                Library:Notify("Jason skin disabled - reverted to default Slasher", 4)
                if lp.Character then RevertJason(lp.Character) end
            end
        end
    })            
    SkinGroup:AddLabel("default Slasher to Jason skin")
end

Library:Notify("c00lSaken loaded! Press RightControl to toggle", 8)
